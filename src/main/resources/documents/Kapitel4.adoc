== 4. Test Driven Development

[.text-justify]
In den Anfängen des Testens war alles ganz einfach.
Man schrieb Code, dann schrieb man Tests umd seine Gültigkeit zu überprüfen.
Das schien vernünftig zu sein und brachte gute Ergebnisse.
Doch nach einiger Zeit beschlossen einige Personen, die Dinge auf den Kopf zu stellen und bestanden darauf, Test vor der Implementierung zu schreiben.
Diese eher überraschende Idee wurde ziemlich populär und es wird behauptet, dass sie zu noch besseren Ergebnissen führt.

[.text-justify]
Ursprünglich war das Schreiben von Tests vor dem Schreiben des eigentlichen Codes eine Möglichkeit, diesen so schnell wie möglich zu verifizieren.
Als immer mehr Menschen begannen, den Test-first-Ansatz zu verfolgen, entdecken diese bald, dass die sofortige Überprüfung nur ein Teil der Vorteile ist, die man erhält, wenn man zuerst Tests schreibt.
Es stellte sich heraus, dass das Nachdenken über die Tests, bevor eine Implementierung geschrieben wurde, eine leistungsstarke Entwurfstechnik ist.
Der Code funktionierte nicht nur besser, dank der gründlichen Tests, sondern sah auch besser aus und fühlte sich besser an, was die Architektur, die Wartbarkeit und die Benutzerfreundlichkeit der API anbelangt.

[.text-justify]
Daher wird test-first heute eher als testgetriebene Entwicklung (TDD) bezeichnet.
Es gibt immer noch einige Diskussionen über die Beziehung zwischen TDD und test-first.
Es scheint jedoch, dass das allgemeine Verständnis dieser Begriffe darin besteht, dass sie wirklich dasselbe bedeuten.

[.text-justify]
In diesem Kapitel werden wir uns genauer ansehen, was es bedeutet, Tests vor der Implementierung zu schreiben.
Neben der Vermittlung des theoretischen Hintergrunds werden wir uns auf die Praxis konzentrieren.
Es ist wichtig, sich daran zu erinnern, dass, obwohl der test-first-Ansatz ausschließlich an Unit-Tests demonstriert wird, dies nicht bedeutet, dass die Anwendbarkeit von TDD auf diese spezielle Art von Tests beschränkt ist!
Im Gegenteil, dieser Ansatz kann, und sollte, auf jeder Testebene verwendet werden.

[.text-justify]
Doch zunächst wollen wir uns verschiedene Antworten auf die folgende Frage ansehen: "Wann sollte man Tests schreiben?"

=== 4.1 Wann Tests schreiben?

[.text-justify]
In den vorangegangenen Abschnitten haben wir bereits zwei Antworten auf diese Frage gegeben:

* Tests nach der Implementierung schreiben.

* Test vor der Implementierung schreiben.

[.text-justify]
Offensichtlich handelt es sich bei den Aussagen um Widersprüche.
Du musst entscheiden, welche Regel du für ein bestimmtes Stück Code befolgen willst.
Es ist jedoch möglich, beide Regeln für den gesamten Kodierungsprozess zu verwenden und für jede Implementierungsaufgabe oder jeden Codeteil die geeignetere Regel zu wählen.

[.text-justify]
Aber es gibt noch eine weitere Antwort auf die Frage "Wann soll man Tests schreiben?", die die beiden zuvor genannten ergänzt:
"Schreibe jedes Mal einen Test, wenn ein Fehler gefunden wird".
Betrachten wir die Ansätze mal etwas genauer.

==== 4.1.1 Test Last

[.text-justify]
Beim Test-Last Ansatz werden die Tests geschrieben, nachdem der Produktionscode fertiggestellt wurde.
Dies ist ein "traditioneller" Ansatz für das Testen, der dem neueren "Test First" Ansatz vorausgeht.

[.text-justify]
Das Schreiben der Tests nach dem Code hat Vor- und Nachteile.
Der Hauptvorteil ist, dass die Tests geschrieben werden, wenn die Funktionalität des getesteten Objekts gut verstanden wird.
Der größte Nachteil ist, dass der Entwickler sich auf das Testen der Implementierung konzentriert, die er in der Regel nur ein paar Minuten zuvor geschrieben hat, anstatt die Schnittstelle, das Verhalten, des SUT zu testen.
Dies kann zu Tests führen die:

[.text-justify]
* eng an die Implementierung gekoppelt sind, und als solche bei jeder Änderung neu geschrieben werden müssen.

[.text-justify]
* die Entwickler ermutigen, (un)bewusst die Art von Testfällen auszuwählen, von denen sie erwarten, dass sie sie erfolgreich bestehen.

[.text-justify]
Außerdem besteht bei der Verwendung des "Test Last" Ansatzes immer die Versuchung, überhaupt keine Tests zu schreiben.
Warum sollte man sich die Mühe machen, wenn man ziemlich sicher ist, dass der Code wie erwartet funktioniert?
Warum sollte man sich die Mühe machen, wenn man die Sache laufen lässt und mit eigenen Augen sieht, dass die Protokollmeldungen genau so sind, wie man sie haben wollte?
Es erfordert eine Menge Selbstdisziplin, Tests zu schreiben, nachdem man einen funktionierenden Code hat.
Und wenn der Abgabetermin näher rückt, wird die Versuchung groß, etwas Zeit zu sparen, indem man diesen zusätzlichen, scheinbar unnötigen Schritt vermeidet.
Dies ist, meiner persönlichen Meinung nach, ein wichtiger Grund, den Test-First-Ansatz zu verfolgen.

[.text-justify]
In manchen Fällen, zum Beispiel bei der Arbeit an Legacy Code ist der "Test Last" Ansatz die einzig mögliche Vorgehensweise, der der Code bereits existiert.

==== 4.1.2 Test First Development

[.text-justify]
Das Schreiben der Tests vor dem eigentlichen Code veranlasst die Entwickler, über das Verhalten des getesteten Objekts nachzudenken und nicht über seine Implementierung, die zu diesem Zeitpunkt ja noch nicht existiert.
Es reduziert die Funktionalität jeder implementierten Klasse auf das durch die Testfälle bestimmte Minimum, es werden keine überflüssigen Funktionalitäten hinzugefügt.
Dies führt auch zu einer sehr hohen, wenn auch nicht 100%igen, Codeabdeckung.
Dies ist im Allgemeinen wünschenswert.
Dieser Ansatz kan auf jeder Testebene angewendet werden.
Insbesondere ist er für Unit-Tests sehr beliebt und geeignet.

==== 4.1.3 Immer, nachdem ein Bug gefunden wurde

[.text-justify]
Das Erste, was du tun solltest, nachdem du einen Fehler gefunden haben, ist, deinen natürlichen Drang zu zügeln, ihn sofort zu beheben.
Wenn du ihn "einfach so" behebst, verpasst du eine Gelegenheit, ihn ein für alle Mal loszuwerden.
Der Fehler kann später wieder auftauchen, weil jemand die Änderung rückgängig gemacht hat, zum Beispiel bei der Behebung eines anderen Fehlers.
Wenn du aber einen Test schreibst, bevor du den Fehler behebst, stärkst du dein Sicherheitsnetz aus Tests und derselbe Fehler wird nicht wieder auftreten.

[.text-justify]
Unabhängig davon, ob du Test-First oder Test-Last programmierst, sollten du sofort nach dem Auftreten eines Fehlers einen Test schreiben.
Der Test sollte den Fehler aufdecken, d.h. er sollte erwarten, dass das Richtige passiert, in diesem Fall also fehlschlagen, und somit das fehlerhafte Verhalten wiederholen.
Danach solltest du den Code so korrigieren, dass der Test erfolgreich ist.

[.text-justify]
Wenn man darüber nachdenkt, wirst du feststellen, dass das Schreiben eines Tests, nachdem ein Fehler gefunden wurde, eigentlich einem Test-First-Ansatz entspricht.
Du schreibst einen Test, der fehlschlägt, weil man den Fehler ja nachahmen möchte, und dann implementiert man den Code korrekt, um den Test bestehen zu lassen.

[.text-justify]
Das große Problem dabei ist, den Fehler genau zu lokalisieren, so dass du einen Unit-Test schreiben kannst, der diesen aufdeckt.
Das kann wirklich schwierig sein.
Es kann sein, dass mehrere Fehler in deiner Geschäftslogik auftauchen, während du auf die Benutzeroberfläche deiner Anwendung klickst.
Es ist nicht so einfach, genau zu sagen, welche Klasse für ein bestimmtes fehlerhaftes Verhalten verantwortlich ist.
In der Regel wird dieses Problem dadurch gelöst, dass zunächst ein übergeordneter Test, d.h. ein End-To-End-Test, geschrieben wird und dann nach und nach Informationen über die Ursache gesammelt werden, wobei das Suchfeld durch das Schreiben gezielterer Test eingegrenzt wird: zunächst Integrations- und dann schließlich Unit-Tests.

=== 4.2 TDD Rhythmus

[.text-justify]
Das Schöne am Test-First Ansatz ist, dass er aus ein paar sehr einfachen Schritten besteht, die immer und immer wieder wiederholt werden.
Und - was beim ersten Mal ziemlich überraschend ist - diese einfachen Schritte führen zu einer großartigen Kodierungserfahrung und großartigen Ergebnissen.
Pure Magie, nicht wahr?

[.text-justify]
Werfen wir einen Blick auf die stark vereinfachte Abbildung.
Sie zeigt nicht die ganze Wahrheit.
Doch im Verlauf dieses Kapitels werden wir es noch um einige Details erweitern.
Es handelt sich aber dennoch um eine Abbildung, die man sich zu Beginn gerne über dem Schreibtisch aufhängen sollte.
Es beschreibt nämlich den Rhythmus deiner Arbeit.

1. Man schreibt einen Test der fehlschlägt (Rot)

2. Korrigiere den Code, sodass der Test erfolgreich verläuft (Grün)

3. Beseitige Redundanzen (REFACTOR)

[.text-justify]
Hierbei handelt es sich auch um eine einfache Regel, die du befolgen solltest.
Schreibe niemals Code ohne einen fehlgeschlagenen Test.

:figure-caption: Abbildung
.Der TDD Rhythmus
image::/Users/aloran/ownprojects/Textgeneration/src/main/resources/pictures/TDD Rhythmus.png[Der TDD Rhythmus,align="center"]

[.text-justify]
Die nächste Abbildung gibt einen erweiterten Einblick in den TDD-Rhythmus.
Es zeigt, wie man mit einer Liste von Tests beginnt, einen davon auswählt und dann dem Rot-Grün-Refactor Zyklus folgt, um sicherzugehen, dass man am Ende bei grün landet.

[.text-justify]
Die gesamte Arbeit ist abgeschlossen, d. h. eine bestimmte Funktionalität ist implementiert, wenn keine Tests mehr geschrieben werden müssen.

:figure-caption: Abbildung
.Der TDD Rhythmus erklärt
image::/Users/aloran/ownprojects/Textgeneration/src/main/resources/pictures/TDDRhythmusErklaert.png[Der TDD Rhythmus erklärt,align="center"]

[.text-justify]
In den nun folgenden Abschnitten werden wir jeden Schritt des Rhythmus genauer betrachten.

==== 4.2.1 ROT - Schreibe einen Test der fehlschlägt

[.text-justify]
Überlege dir eine Funktionalität, die implementiert werden sollte und schreiben diese in Form eines Tests auf.
Diese Funktionalität ist noch nicht implementiert, sodass der Test unweigerlich fehlschlagen wird.
Das ist an dieser Stelle auch das gewünschte Verhalten.
Somit weis man nun:

[.text-justify]
* die Funktionalität funktioniert wirklich nicht,

[.text-justify]
* sobald diese Implementiert ist, wirst du es sehen, weil das Testergebnis von rot auf grün wechselt.

[.text-justify]
Am Anfang mag es dir unangenehm sein, Tests zu Funktionalitäten zu schreiben, die gar nicht vorhanden sind.
Es erfordert eine geringfügige Änderung deiner Programmiergewohnheiten, aber nach einiger Zeit wirst du es als eine großartige Gelegenheit für das Design sehen.
Wenn du zuerst Tests schreibst, hast du die Chance, eine API zu erstellen, die für einen Kunden bequem zu benutzen ist.
Dein Test ist der erste Client für diese neu entstandene API.
Genau darum geht es bei TDD: Um den Entwurf einer API.

[.text-justify]
Wenn du wie ein Kunde an den eigenen, bald zu schreibenden Code denkst, solltest du dich auf das konzentrieren, was wirklich erforderlich ist.
Du musst dir Fragen stellen wie "Brauche ich wirklich diesen Getter", der die Sammlung zurückgibt, oder wäre es bequemer, eine Methode zu haben, die das größte Element dieser Sammlung zurückgibt?
Und diese Fragen kannst du nur beantworten, indem du Tests schreibst.
Hierdurch entstehen keine unnötigen Methoden mehr, die geschrieben werden, weil sie "vielleicht irgendwann einmal für jemanden nützlich sein könnten", keine automatisch generierten Setter/Getter mehr, wenn eine unveränderliche Klasse viel besser geeignet ist.
Konzentriere dich auf das, was der Kunde (der Testcode) wirklich braucht.
Und schreibe Tests, die genau das testen, und nicht mehr!

[.text-justify]
Wenn du zuerst einen Test schreibst, musst du in Bezug auf die API des Objekts denken.
Du wirst noch nicht wissen, wie die Implementierung aussehen wird, auch wenn du eine Vorstellung hiervon hast.
Das ist auch gut so.
Es bedeutet, dass deine Tests mehr Chancen haben das externe Verhalten des Objekts zu testen und nicht seine Implementierungsdetails.
Dies führt zu besser wartbaren Tests, die nicht untrennbar mit der Implementierung verbunden sind.

[.text-justify]
Natürlich kannst du den Test nicht direkt nach dem Schreiben ausführen.
Warum?
Wenn du wirklich die Regel "Schreibe niemals Code ohne einen fehlgeschlagenen Test" befolgst, dann würde dein Test einige nicht existierende Klassen und Methoden verwenden.
Er ließe sich einfach nicht kompilieren.
Als Teil dieses ersten Schritts du also auch dafür sorgen, dass der Test kompiliert wird.
Normalerweise lässt sich das durch eine vernünftige IDE einfach lösen, indem man eine (leere) Standardimplementierung von Klasse und Methoden erstellt, die vom Testcode verwendet werden.

===== 4.2.1.1 Wie man den nächsten zu schreibenden Test auswählt

[.text-justify]
Jemandem zu sagen, dass man einfach losgehen und einen fehlgeschlagenen Test "einfach so" schreiben soll, ist irgendwie unfair.
Es hört sich einfach an, aber wie soll man vorgehen?
Nehmen wir an, wir haben eine Liste von Funktionalitäten, die implementiert werden sollen und eine Liste von Tests, die diese abdecken.
Die Frage, mit der wir uns jetzt beschäftigen müssen, ist, wie wir den ersten Test auswählen.
Und wie geht man dann, nachdem man ihn implementiert und den TDD Zirkel mit der Implementierung des Codes und dem Refactoring abgeschlossen hat, mit dem nächsten Test um?
Und der Nächste?

[.text-justify]
Hierbei handelt es sich um ein Standardproblem und, soweit ich weiß, gibt es keine "Standard"-Lösung.
Es gibt keine Heuristik, die allgemein als der richtige Weg anerkannt ist, um den nächsten zu implementierenden Test zu bestimmen.
Es gibt jedoch einige Tipps in der Community, die hilfreich sein könnten.
Diese werden nun im Detail beschrieben.

[.text-justify]
*Die niedrig hängende Frucht* (Low-Hanging Fruit).
Diese Regel besagt: "Beginne mit etwas wirklich Einfachem.
Implementiere einen offensichtlichen Testfall."

[.text-justify]
Diese Technik ist besonders nützlich, wenn man nicht weiterkommt.
Etwas zu schreiben, auch wenn es trivial oder nur von geringer Bedeutung ist, kann hilfreich sein, um diese Art von "Schreibblockade" zu überwinden.
Wenn man sich nicht sicher ist, welche Tests zu schreiben sind und wie sich die getestete Methode verhalten soll, ist der erste Schritt vielleicht das Beste, was man tun kann.
Selbst wenn die auf diese Weise implementierte Funktionalität nicht so wichtig ist, werden dadurch zumindest einige teile des Puzzles zusammengesetzt.
Das hilft jemandem, um weiterzukommen.

[.text-justify]
Ein Beispiel für das Schreiben eines einfachen Testsfalls, um den Einstieg zu erleichtern, wäre:

[.text-justify]
* das Schreiben eines Tests zur Überprüfung von Parametern für eine Funktion

[.text-justify]
* das Schreiben eines Parsers.
Man beginnt mit dem Testfall der Übergabe eines leeren Strings an die Parsing Methode und erwartet als Rückgabewert null zu erhalten.

[.text-justify]
In keinem der beiden Fälle würde man die, wahrscheinlich recht komplexe Hauptlogik anfassen, die getestet und implementiert werden muss.
Man würde jedoch einen Einblick in Klassen und Methoden erhalten, die die eigentliche Aufgabe bereitstellen.
Dies kann sehr nützlich sein, wenn man zu dem Zeitpunkt einfach nicht mehr weiter weiß.

[.text-justify]
*Der Informativste* Ein anderer Ansatz besteht darin, mit dem Test zu beginnen, der einem die meisten Informationen über die zu implementierende Information liefert.
Das ist so, als würde man den Ball mit dem Sweet Spot treffen: Er liefert den größtmöglichen Erkenntnisgewinn.

[.text-justify]
Das bedeutet jedoch in der Regel, sich den schwierigsten Dilemmas zu stellen.
Aber man muss sich ja eh mit ihnen auseinandersetzen.
Warum also nicht einfach direkt ins Geschehen einsteigen, anstatt sich im Kreis zu drehen?

[.text-justify]
TIP: Das ist so, als würde man sagen: "Es spielt keine Rolle, das ich im ersten Spiel gegen den Weltmeister antrete, wenn ich das ganze Turnier gewinnen möchte, muss ich ihn eh schlagen." Manche Personen mögen diese Art der Motivation.

[.text-justify]
Alles schön und gut, aber haben wir nicht gerade ein Rätsel mit einem anderen Rätsel beantwortet?
Die Frage ist nun, woher weis man welcher Test das meiste Wissen über die implementierende Funktionalität liefert?
Nun, das ist gar nicht so schwer zu beantworten.
Dies ist wahrscheinlich der Test, von dem man weiß, dass man noch nicht weiß, wie man diesen besteht.
Man merkt es ziemlich schnell welcher das sein wird.

[.text-justify]
Hätte man im Falle des vorangegangenen Parser-Beispiels diesen Ansatz gewählt, hätte man wahrscheinlich mit dem Parsen eines ganzen Satzes begonnen.
Dadurch würde man sicherlich viel über die implementierende Funktionalität lernen.

[.text-justify]
*Erst der typische Fall, dann die Grenzfälle*.
Es erscheint durchaus sinnvoll, mit einem "typischen Fall" zu beginnen.
Man überlegt sich einfach, wie man selbst erwarten würde, wie eine Funktion am häufigsten verwendet wird.
Wenn man beginnt einen Tokenizer zu schreiben, beginnt man mit einem gültigen Satz als Eingabe.
Wenn man einen Verkaufsautomaten implementiert, beginnt man mit einem Kunden, der eine 1 € Münze einwirft und ein Produkt aus dem Angebot des Automaten auswählt.
Später werden denn die Grenzfälle implementiert.

[.text-justify]
Außerdem garantiert dieser Ansatz, dass man von Anfang an etwas Wertvolles in Arbeit hat.
Selbst, wenn man vom Computer weggezerrt werden sollte, hat mein bereits etwas implementiert, was für die Kunden des SUT nützlich ist.

[.text-justify]
TIP: Ich selbst verfolge meist diesen Ansatz

[.text-justify]
*Höre auf deine Erfahrung*: Der wahrscheinlich wertvollste Weg, mit dem Dilemma des "nächsten Tests" umzugehen, ist, auf die eigene Erfahrung zu hören.
Diese sollte einem sagen, welcher der oben genannten Ansätze für diesen speziellen Fall am besten geeignet ist.

[.text-justify]
*Lesbare Assertion Nachricht*

[.text-justify]
Nachdem man einen fehlgeschlagenen Test gefunden hat und bevor man mit der Implementierung von Code beginnt, um den fehlgeschlagenen Test zu beheben, ist es ratsam, sich um weitere Details zu kümmern: Stelle immer sicher, dass die Meldungen vom fehlgeschlagenen Test, auch aussagekräftig genug sind um den Fehler herauszufinden.
Ist dies nicht der Fall, bearbeitet man die Fehlermeldung, bis diese zufriedenstellend ist.

==== 4.2.2 GRÜN - Schreibe das Einfachste, was funktioniert

[.text-justify]
Da man nun einen fehlgeschlagenen Test sowie eine klare Assertion-Meldung hat, ist der nächste Schritt den Test zum Bestehen zu bringen.
Natürlich gelingt dies nur durch das Schreiben von Code!

[.text-justify]
Der Punkt ist es hierbei aber nicht zu übertreiben.
Es geht darum *die kleinste Menge an Code zu schreiben, die den Test erfüllt*.
Man hat sich auf die eigentliche Aufgabe zu konzentrieren.
Und diese lautet: "Mach den Balken grün".
Das war es auch.
Denke nicht zu viel über Erweiterungen nach.
Das interessiert zu diesem Zeitpunkt nicht.
Mach den fehlgeschlagenen Test grün, nichts weiter.
Ganz gewiefte sagen nun: "Pff, dann deklariere ich die Methodensignatur und schreibe nichts in den Methodenrumpf rein.
Dann ist der Test auch grün".
Dem entgegne ich persönlich dann: "...hör auf in der Informatik zu arbeiten und mach was wo Faken gern gesehen ist.
BWL zum Beispiel." Der Grund ist: "DU TESTEST NICHT!"

[.text-justify]
Denk daran, dass es weitere Tests geben wird.
Diese werden dann die anderen Anforderungen abdecken.
Und wenn die Zeit gekommen ist, hat man alle Funktionen hinzugefügt, die man sich im Kopf ausgedacht hat.

==== 4.2.3 REFACTOR - Verbessere den Code

[.text-justify]
Die Frage ist, ob das Hinzufügen einfacher Funktionen nach und nach nicht dazu führt, dass der endgültige Code wie ein Haufen von wahllos eingeordneter Elemente aussieht.
Der Code wird funktionieren, aber wird der Code einfach zu verbessern sein?
Wird er flexibel sein?
Wird er OOP Prinzipien KISS, DRY, SRP und andere Einhalten?
Und so gelangen wir zum nächsten Schritt des TDD-Rhythmus: Refactoring.

[.text-justify]
Sobald der Test bestanden ist, können nun Änderungen am Code vorgenommen werden.
Das Sicherheitsnetz, das es nun durch die Tests gibt, gibt einem nun die Gewissheit, dass man nicht mehr kaputt machen kann, solange der Balken grün bleibt.
Ändere Methodennamen, aktualisiere den Geltungsbereich von Variablen, verschiebe Teile von einem zum anderen Ort.
Führe die Tests oft genug aus.
Sie werden sofort mitteilen, ob und welchen Schaden das Refactoring angerichtet hat.

[.text-justify]
Weswegen ist dieser Schritt erforderlich?
Wie manche Leute sagen: "Wenn es funktioniert, brauchst du es nicht zu reparieren" - warum sollten man sich mit dieser Aufgabe belasten?
Die Antwort ist, dass man sich während des vorangegangenen Schritts, lediglich auf das Erfüllen des Tests konzentriert hat und der implementierte Code möglicherweise nicht klar genug ist.
Er funktioniert zwar, kann aber ein Albtraum in der Wartung sein.
Und darüber hinaus hat man in der Programmierung von "nur so viel, wie nötig ist, um den Test zu bestehen" nur an dieses Stück Code gedacht.
Jetzt ist es aber an der Zeit, das Gesamtbild zu betrachten und den gesamten Code zu überarbeiten, nicht nur die paar Zeilen, die man vor einigen Minuten geschrieben hat.
Vielleicht gibt es nun einige Redundanzen, vielleicht sollte einige Funktionen in eine private Funktion verschoben werden, vielleicht sollten einige Variablen umbenannt werden.
Jetzt ist es an der Zeit dies zu tun.

[.text-justify]
TIP: Wenn man ein "Refactoring" durchgeführt hat und die Tests trotzdem bestanden wurden, aber die Anwendung nun nicht mehr funktioniert, bedeutet dies, dass man nicht wirklich ein Refactoring durchgeführt hat.
Man hat nur den Code geändert.
Refactoring bedeutet, sich über ein Sicherheitsnetz von Tests zu bewegen.
Es bedeutet, mit Code zu arbeiten, der gründlich getestet ist.
Man ist unfair gegenüber dem "Refactoring", wenn man es beschuldigt etwas kaputt gemacht zu haben.
Man hat es einfach selbst schlecht gemacht.
Was bedeutet man hat nicht genug getestet.

[.text-justify]
*Tests Refaktorieren*

[.text-justify]
Sollte man auch Tests refaktorieren?
Ja!
Das sollte man!
Betrachte Tests wie ein wertvolles Gut.
Man wird diese häufig lesen und aktualisieren.
Sie sind das Fundament, auf dem man den Code aufbaut und als solches sollten diese robust und von höchster Qualität sein.
Die Qualität des Codes hängt stark von den Tests ab, daher vertraue darauf, dass diese wirklich gut sind.

[.text-justify]
Beim Refactoring wird der Code umstrukturiert, ohne seine Funktionalität zu verändern.
In Bezug auf Tests bedeutet dies, dass die refaktorisierten Tests dieselben Methoden aufrufen, dieselben Argumente verwenden und dieselben Assertions überprüfen, wie man es vor Beginn des Refactorings getan hat.

[.text-justify]
Ein offensichtliches Problem beim Refactoring von Tests ist, dass es keine Tests für die Tests selbst gibt, sodass man aus Versehen einige unerwünschte Änderungen eingeführt hat, anstatt ein Refactoring durchzuführen.
Diese Gefahr besteht, ist aber nicht so ernst, wie es auf den ersten Blick scheinen mag.
Zunächst einmal sind Unit-Tests, wenn sie richtig geschrieben sind, wirklich einfach.
Sie enthalten keine komplexe Logik, die bei Änderungen zum Zusammenbruch führen könnte.
Beim Refactoring von Tests geht es eher darum, Dinge zu verschieben - zum Beispiel das Verschieben einiger allgemeiner Funktionen in Setup-Methoden.
Wenn man etwas falsch macht, ist es sehr wahrscheinlich, dass der grüne Balken auf Rot wechselt und einen sofort darauf hinweist, dass etwas schiefgelaufen ist.

[.text-justify]
Zusammenfassend lässt sich sagen, dass man mit Vorsicht vorgehen, aber keine Angst vor dem Refactoring ansich haben sollte.
Man sollte sich immer vergewissern, dass sich die Anzahl der ausgeführten Tests nicht geändert hat und wenn man sich mit den beim Refactoring eingeführten Änderungen nicht sicher fühlt, kann man immer noch einen Blick auf den Codeabdeckungsbericht werfen.

[.text-justify]
*JavaDocs anfügen*

[.text-justify]
Während einer Refactoring-Phase sollte man sich auch um die JavaDocs kümmern, sowohl für den Produktionscode als auch für die Tests.
Das wirft aber zwei Probleme auf:

[.text-justify]
1. Das Design ist noch nicht festgelegt.
Hat es einen Sinn, jetzt eine Dokumentation zu schreiben, wenn die Dinge vielleicht noch geändert werden?

[.text-justify]
2. Die Dokumentation jetzt zu schreiben, kann den Gedankenfluss stören.
Das Gehirn konzentrieren sich bereits auf den nächsten Test, der geschrieben werden muss.
Ist es eine gute Idee, diesen sogenannten "Fluss" zu unterbrechen und sich einer anderen Tätigkeit zuzuwenden?

[.text-justify]
TIP: Diese berechtigte Fragen werden durch die natürliche Abneigung der Entwickler gegen das Schreiben von Dokumentationen noch verstärkt.
Dies führt dazu, dass die Erstellung der Dokumentation aufgeschoben wird, was wiederum dazu führt, dass es überhaupt keine Dokumentation gibt. kurzfristig scheint das wirklich cool zu sein, aber langfristig ist das tödlich.

[.text-justify]
Folgendes schlage ich persönlich aus Erfahrung vor:

[.text-justify]
1. Fasse dich Kurz.
So tut es weniger weh.
Schreibe nur über den geschäftlichen Zweck der Klassen und Methoden und über alle wichtigen Designentscheidungen.

[.text-justify]
2. Wenn man den Codefluss wirklich nicht unterbrechen will, hinterlasse eine Notiz für dich selbst.
Sogenannte TODOs.
Die Dokumentation, vor allem die JavaDoc, sollte nie vergessen werden.

[.text-justify]
IMPORTANT: Vergesse niemals, dass man Code schreiben sollte der sich selbst dokumentiert.
Verwende beschreibende Methodennamen und schreibe gute und lesbare Tests.
Dann kann man auf das Schreiben von JavaDocs auch verzichten (außer einige Erklärungen auf höherer Ebene).
Dies ist der erstrebenswerte Zustand.
Aber, wie in jeder Programmiersprache, sind semantische Beschreibungen im Code begrenzt.
Daher wird sich das nie zu 100 % erreichen lassen können.

==== 4.2.4 Und nochmal von vorne

[.text-justify]
Führe, nach der Umstrukturierung des Codes, die Tests erneut durch, um sicherzustellen, dass keine Schäden entstanden sind.
Denke daran ALLE Unit-Tests auszuführen, nicht nur die an denen man kürzlich gearbeitet hat.
Unit-Tests werden schnell ausgeführt.
Man gewinnt keine Zeit, wenn man nur ausgewählte Tests ausführt.
Führe alle Tests aus, stelle fest, dass sie erfolgreich sind und dann kann man mit dem nächsten Test fortfahren.
Wiederhole den Vorgang so lange, bis keine Tests mehr schrieben werden müssen.

=== 4.3 Vorteile

[.text-justify]
_"TDD hilft bei gutem Design und gutem Code, ist aber keine Garantie dafür.
Geschick, Talent und Fachwissen sind weiterhin erforderlich"_ - Esko Luontola

[.text-justify]
Nun kennt man die Theorie hinter dem TDD Zyklus:

[.text-justify]
- Der gesamte Code (hiermit ist nicht gemeint setter, getter und sonstiges triviales was eher die Programmiersprache selbst als die gewünschte Funktionalität testet) wird durch Unit-Tests abgedeckt.

[.text-justify]
- der Code ist so geschrieben, dass er die Tests erfüllt und es keine überflüssigen Teile im Code gibt, die nur deshalb geschrieben wurden, weil sie "möglicherweise" nützlich sein könnten

=== 4.4 Wie man mit TDD beginnt

[.text-justify]
_"Wir alle sind gleich.
Unter Druck fallen wir auf das zurück, was wir kennen.
Treten beim TDD Probleme auf, hören Entwickler auf, Tests zu schreiben"_ - Ian Cooper

[.text-justify]
Nun haben wir also so einiges über den TDD Ansatz gesprochen.
Er scheint zu Beginn ein wenig umständlich zu sein, aber gleichzeitig erweist er sich auch als sinnvoll.
Vielleicht hat man von einigen großartigen Programmierern gehört, die Tests vor dem Code schreiben.
Vielleicht hat man von einigen Projekten gehört, die nach dem TDD Prinzip entwickelt wurden und für eine hohe Codequalität bekannt sind.
Eventuell hat man im eignen Betrieb auch gehört, dass andere Teams TDD erfolgreich in den Entwicklungsprozess integriert haben und jetzt überlegt man sich selbst dies zu tun.

[.text-justify]
Und du versuchst es nun tatsächlich bei deiner nächsten Aufgabe umzusetzen.
Und es fühlt sich an wie....wie der versuch, eine Wand mit dem eigenen Kopf zu durchbrechen!
Datenbanken, Spring-Kontexte, statische Klassen, ORM-Tools, JNDI-Aufrufe, Webdienste, globale Variablen, tiefe Vererbungshierarchien und Konsolenausgaben springen einem auf einmal entgegen.
Nichts sieht auch nur im Ansatz so aus wie die Test-First-Tutorials die man sich auf Youtube angeschaut hat.
Keiner der guten Ratschläge, die man bekam, scheinen zu helfen.
Es ist schlichtweg unmöglich weiterzumachen!

[.text-justify]
Aber natürlich gibt man sich nicht kampflos geschlagen.
Mühsam und mit zusammengebissenen Zähnen überwindet man ein Problem nach dem anderem.
Das benötigt Zeit...viel Zeit.
Foren und Blogs scheinen auf einmal sehr, sehr gute Freunde zu werden.
Am Ende des Tages schaut man auf seinen Code und denkt sich nur noch...okay...viele Zeilen sind das ja nicht gerade, die da geschrieben wurden.
Mit dem Code-first-Ansatz ist man es gewöhnt ungefähr 10 Mal mehr zustande gebracht zu haben.
Man ist nicht einmal stolz auf die eigenen Tests, weil man weiß, welche Dirty Hacks man verwendet hat, um sie zum Laufen zu bekommen.
So zumindest erging es mir bei meiner ersten Begegnung mit TDD.

[.text-justify]
Bevor man nun in tiefer Verzweiflung versinkt, hier einige, sehr hart erlernte und wirklich gut gemeinte Ratschläge.
Lieber TDD-Wannabe-Programmierer.
Du hast versucht zu viel auf einmal zu machen!
Du hast versucht deine Gewohnheit zu ändern, was ansich schon schwer genug ist, und gleichzeit auch mehrere Probleme zu lösen, die in der Codebasis existieren.
Selbst wenn man einige Tests hatte, was ich zumindest stark hoffe, so wurde der Code mit ziemlicher Sicherheit nie mit einem Blick auf Testbarkeit geschrieben.
Der Versuch neue Funktionen auf testorientierte Weise hinzuzufügen, ist wie eine Herausforderung für die alte Codebasis.
Sie wird sich wehren!
Sie wird versuchen deine Bemühungen zu vereiteln.
Dieselben Lösungen, auf die man zuvor recht stolz war, sind schlimmstenfalls die, die dich jetzt daran hindern weiterzukommen.
Im allerschlimmsten Fall wird dein Pull-Request von einem Kollegen declined, weil er nicht dem gewohnten Code entspricht.

[.text-justify]
Doch wie kam ich selbst aus der Bredouille?
Indem ich das begonnen habe, was TDD selbst fördert.
Das Arbeiten in ganz kleinen Schritten.
Beginne mit den einfachsten Dingen.
Implementiere einfache Aufgaben mit dem Test-First-Ansatz.
Freue dich über jeden TDD Erfolg.
Lerne zeitgleich aber von jedem TDD Misserfolg.
Findet man etwas, was sich mit dem TDD Ansatz nicht bewältigen lässt so mache dir nicht zu viele Gedanken darüber.
Nach ein paar Wochen bist du in der Lage auch diese Herausforderung zu meistern.
Baue deine Erfahrung in kleinen Schritten auf.
Auf diese Weise wird es mit der Zeit funktionieren.
Ich selbst bin der Beweis!

[.text-justify]
Es wird von Tag zu Tag einfacher werden.
Erstens, weil man selbst immer besser wird.
Zweitens aber, hört man auf Dinge zu tun, die man bisher gemacht hat und beginnt seinen Fokus auf den Test zu legen.
Drittens ist der Entwurf nun auch viel besser und somit die nächsten Teile des Codes leichter testbar.
Viertens, und damit hat man es dann auch wirklich geschafft, einige Teamkollegen haben sich dir angeschlossen und produzieren nicht mehr "einen Haufen Scheiße," die sich nicht testen lässt.

=== 4.5 Wann sollte man TDD nicht verwenden?

[.text-justify]
TDD funktioniert hervorragend.
Es ist auch sehr wahrscheinlich, dass du, wenn du es erst einmal im Griff hast, nur noch ungern auf eine andere Weise coden möchtest.
Es gibt jedoch Umstände, unter denen dieser Ansatz nicht die beste Option zu sein scheint.

[.text-justify]
Wie im vorherigen Abschnitt erläutert, ist es wirklich nicht ratsam ins kalte Wasser zu springen.
Auch wenn man ein guter Programmierer ist kann es durchaus sein, dass man noch nicht dafür bereit ist reale Programmieraufgaben nach dem TDD Ansatz zu lösen.
Beginne mit etwas Einfachem.
Sammle Erfahrungen und nutze es dann erst.

[.text-justify]
Dass bedeutet, das die erste Anti-Test-First Situation darin besteht, alle möglichen Probleme gleichzeitig in Angriff zu nehmen, während es an Erfahrung, Fähigkeiten und Vertrauen in diese mangelt.
Tue das auf gar keinen Fall!

[.text-justify]
Und selbst dann, wenn man einige Erfahrung gesammelt hat, wird TDD immer noch einen etwas behindern.
Wie Kent Beck, der versucht hat, ein neues Eclipse Plugin zu implementieren, ohne sich mit der Technologie auszukennen, einmal geschrieben hat: _"Sechs oder acht Stunden lang, verteilt über die nächsten Wochen, kämpfe ich darum, den ersten Test zu schreiben und zum Laufen zu bekommen. [...] Hätte ich einfach etwas geschrieben und es von Hand überprüft würde ich wahrscheinlich schon die endgültige Antwort darauf haben, ob meine Idee ihr Geld auch wert ist.
Stattdessen habe ich nur einen komplizierten Test, der nicht funktioniert, einen Haufen Frust und acht Stunden weniger Lebenszeit [...]."_ - Ken Beck, Just Ship, Baby (2009).

[.text-justify]
Das Schreiben von Tests erfordert in der Regel ein gutes Verständnis der verwendeten Technologien und Kenntnisse über den Problembereich.
Fehlen einem diese Kenntnisse, ist es besser mit dem Code First Ansatz zu beginnen.
Vor allem, wenn man im Moment nicht die Zeit hat sich diese anzueignen.
Man Weis, dass man die Zeit damit verbringen muss, sich in ein noch unbekanntes Test-Framework einzuarbeiten anstatt echten Code zu schreiben.
Wie immer sollte hier der gesunde Menschenverstand einsetzen und einen aus den eigenen Fehlern lernen lassen.

[.text-justify]
Ein weiteres Hindernis für den TDD Ansatz ist legacy code.
Es kann sein, dass du nicht in der Lage bist, TDD ohne ein ernsthaftes Refactoring anzuwenden.
Du wirst aber auf ein Henne-Ei-Problem stoßen, weil ohne ein Sicherheitsnetz von Tests Refactoring schwer ist.

[.text-justify]
Hier sei aber eine Sache gesagt.
Nach meiner Erfahrung gilt dies nur für Integrations-Tests.
Für Unit-Tests gilt dies nicht.
Es ist immer möglich, zumindest einige Zustandstests auf diese Weise durchzuführen.
Was das Testen von Interaktionen zwischen Objekten betrifft, so ist dies manchmal deutlich schwieriger.